First lesson: use snake case for methods, script names/modules and functions.
snake case: using all lowercase letters and separating words with underscores.
so instead of RNAfold.py use rna_fold.py for script name.
> Warning in VScode: Module name "RNAfold" doesn't conform to snake_case naming style.

lesson 2: when using anaconda create a seperate conda enviroment for each project.
That way you can load the python version and dependencies you need without dependency problems.
each package will exist only in that enviroment.
> here in install biopython only in the rna_fold enviroment.

lesson 3: biopython
biopython is a bioinformatics module with a lot of functions.
Here I am using it to load fasta files into python.
> Install biopython under conda: conda install -c conda-forge biopython
> import: import Bio

lesson 4: install pandas for data manipulation and data frame usage
> conda install pandas
> import pandas as pd

lesson 5: Sequences from FASTA-files are read as <class 'Bio.Seq.Seq'>
> see print(type(virus.seq)) in code/import_fastafile.py
Need to convert them to string with str-function
virus_list.append([virus.id,str(virus.seq)])


lesson 6: convert lists/dict to dataframe objects.
dont fill empty dataframe objects directly!
Use a list to collect your data, then initialise a DataFrame when you are ready.
Either a list-of-lists or list-of-dicts format will work, pd.DataFrame accepts both.
Pros of this approach:
It is always cheaper to append to a list and create a DataFrame in one go than
it is to create an empty DataFrame (or one of NaNs) and append to it over and over again.
Lists also take up less memory and are a much lighter data structure to work with, append, and remove (if needed).
dtypes are automatically inferred (rather than assigning object to all of them).
A RangeIndex is automatically created for your data, instead of you having to take
care to assign the correct index to the row you are appending at each iteration
this is also mentioned in the documentation:
"Iteratively appending rows to a DataFrame can be more computationally intensive than a single concatenate.
A better solution is to append those rows to a list and then concatenate the list with the original DataFrame all at once."
source: https://stackoverflow.com/questions/13784192/creating-an-empty-pandas-dataframe-and-then-filling-it (last 30.09.23)

lesson 7: use .append in lists and in dictionaries that contain lists
> see import_fastafile.py where i append elements to lists and dictionaries containing lists as values.
virus_dict["id"]=virus.id doesn´t work because each new value in the for loop overwrites the last one.
append doesn´t overwrite it. beware: for dict you need (empty) lists as values. None or other datatypes dont work.
adding this way dict["(new)key"]= new_value works only if the key is new and not used already.

lesson 8: iloc vs loc in pandas
In pandas, iloc and loc are two methods used to access data from a DataFrame
iloc (Integer Location):
iloc is used to access data based on integer positions or indices.
You specify row and column indices using integer values.
It is primarily used when you want to select data based
on its numerical position in the DataFrame, regardless of the row or column labels.
value = df.iloc[0, 1]
loc (Label Location):
loc is used to access data based on labels or row/column names.
You specify row and column labels using the actual label values.
It is primarily used when you want to select data based
on the row or column labels, which can be non-integer (character)
value = df.loc['X', 'B']